PRINTF(3) Linux 程序员手册 PRINTF(3)

姓名
printf、fprintf、dprintf、sprintf、snprintf、vprintf、vfprintf、vdprintf、vsprintf、vsnprintf - 格式化输出转换
锡安

概要
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t 大小, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_​​list ap);
int vfprintf(FILE *stream, const char *format, va_​​list ap);
int vdprintf(int fd, const char *format, va_​​list ap);
int vsprintf(char *str, const char *format, va_​​list ap);
int vsnprintf(char *str, size_t 大小, const char *format, va_​​list ap);

glibc 的功能测试宏要求（请参阅 feature_test_macros(7)）：

snprintf()、vsnprintf()：
_XOPEN_SOURCE >= 500 || _ISOC99_源||
|| /* Glibc 版本 <= 2.19: */ _BSD_SOURCE

dprintf()、vdprintf()：
自 glibc 2.10 起：
_POSIX_C_SOURCE >= 200809L
glibc 2.10 之前：
_GNU_SOURCE

描述
printf() 系列中的函数根据如下所述的格式生成输出。函数 printf()
vprintf() 将输出写入标准输出流 stdout；fprintf() 和 vfprintf() 将输出写入给定的
输出流；sprintf()、snprintf()、vsprintf() 和 vsnprintf() 写入字符串 str。

函数 dprintf() 与 fprintf() 相同，只是它输出到文件描述符 fd，而不是 stdio
溪流。

函数 snprintf() 和 vsnprintf() 最多将 size 字节（包括终止空字节 ('\0')）写入 str。

函数 vprintf()、vfprintf()、vdprintf()、vsprintf()、vsnprintf() 等价于函数 printf()，
分别是 fprintf()、dprintf()、sprintf()、snprintf()，只不过它们是使用 va_list 而不是变量来调用的。
足够的参数数量。这些函数不调用 va_end 宏。因为它们调用了 va_arg 宏，
ap 的值在调用后未定义。请参见标准参数(3)。

所有这些函数都在格式字符串的控制下写入输出，该格式字符串指定后续参数（或
通过 stdarg(3)) 的可变长度参数功能访问的参数将被转换为输出。

C99 和 POSIX.1-2001 指定如果调用 sprintf()、snprintf()、vsprintf() 或 vs‐，则结果未定义
nprintf() 会导致在重叠的对象之间进行复制（例如，如果目标字符串数组和以下之一）
提供的输入参数引用相同的缓冲区）。参见注释。

格式字符串的格式
格式字符串是一个字符串，以其初始移位状态（如果有）开始和结束。格式字符串是
由零个或多个指令组成：普通字符（不是 %），它们被原封不动地复制到输出流；和
转换规范，每个转换规范都会导致获取零个或多个后续参数。每个转换具体
fication 由字符 % 引入，并以转换说明符结尾。在这两者之间可能有（在这个或-
der) 零个或多个标志、可选的最小字段宽度、可选的精度和可选的长度修饰符。

参数必须与转换说明符正确对应（在类型提升之后）。默认情况下，参数
按给定的顺序使用，其中每个“*”（请参阅​​下面的字段宽度和精度）和每个转换说明符要求
下一个参数（如果给出的参数不够多，则会出现错误）。也可以明确指定
在需要参数的每个地方，通过写“%m$”而不是“%”和“*m$”来采用哪个参数
'*'，其中十进制整数 m 表示所需参数在参数列表中的位置，索引起始
从 1. 因此，

printf("%*d", 宽度, 数字);

和

printf("%2$*1$d", 宽度, 数字);

是等价的。第二种样式允许重复引用同一参数。C99标准不包括
使用“$”的样式，来自单一 UNIX 规范。如果使用'$'的样式，则必须使用
贯穿所有采用参数以及所有宽度和精度参数的转换，但它可能与“%%”混合
格式，不消耗参数。使用“$”指定的参数数量可以没有间隙；为了
例如，如果指定了参数 1 和 3，则还必须在格式字符串中的某处指定参数 2。

对于某些数字转换，使用基数字符（“小数点”）或千位分组字符。实际上
使用的字符取决于语言环境的 LC_NUMERIC 部分。（请参阅 setlocale(3)。）POSIX 语言环境使用“.” 作为基数
字符，并且没有分组字符。因此，

printf("%'.2f", 1234567.89);

在 POSIX 语言环境中结果为“1234567.89”，在 nl_NL 语言环境中结果为“1234567,89”，在 da_DK 语言环境中结果为“1.234.567,89”
卡莱。

标记字符
字符 % 后跟零个或多个以下标志：

# 该值应转换为“替代形式”。对于 o 转换，输出的第一个字符
字符串为零（如果它还不是零，则添加前缀 0）。对于 x 和 X 转换，非零结果有
字符串“0x”（或“0X”用于 X 转换）前置。对于 a、A、e、E、f、F、g 和 G 转换，重新
sult 将始终包含小数点，即使其后没有数字（通常，小数点出现在
仅当后面有数字时才显示这些转换的结果）。对于 g 和 G 转换，不会删除尾随零
与其他情况下的结果一样。对于其他转换，结果未定义。

0 该值应该用零填充。对于 d、i、o、u、x、X、a、A、e、E、f、F、g 和 G 转换，转换后的
值在左侧填充零而不是空格。如果 0 和 - 标志同时出现，则 0 标志为 ig‐
诺德。如果通过数值转换（d、i、o、u、x 和 X）给出精度，则忽略 0 标志。为了
其他转换，行为未定义。

- 转换后的值将在字段边界上向左调整。（默认为右对齐。）
转换后的值在右侧用空格填充，而不是在左侧用空格或零填充。A - 覆盖
如果两者都给出则为 0。

' '（空格） 在有符号转换生成的正数（或空字符串）之前应留一个空格。

+ 符号（+ 或 -）应始终放置在由带符号转换生成的数字之前。默认情况下，一个符号是
仅用于负数。如果两者都使用，则 + 会覆盖空格。

上述五个标志字符是在C99标准中定义的。Single UNIX 规范进一步指定了一项
标志字符。

' 对于十进制转换（i、d、u、f、F、g、G），输出将用数千个分组字符进行分组，如果
区域设置信息表示任意。（请参阅 setlocale(3)。）请注意，许多版本的 gcc(1) 无法解析此内容
选项并会发出警告。（SUSv2 不包含 %'F，但 SUSv3 添加了它。）

glibc 2.2 又添加了一个标志字符。

I 对于十进制整数转换（i、d、u），输出使用区域设置的替代输出数字（如果有）。对于前-
足够了，从 glibc 2.2.3 开始，这将在波斯语（“fa_IR”）语言环境中给出阿拉伯-印度数字。

场宽
指定最小字段宽度的可选十进制数字字符串（第一位非零数字）。如果转换后的值
字符数少于字段宽度，则将在左侧（或右侧，如果左侧调整）用空格填充
已给出标志）。除了十进制数字字符串之外，还可以写“*”或“*m$”（对于某些十进​​制整数 m）
指定字段宽度分别在下一个参数或第 m 个参数中给出，其类型必须为
国际。负字段宽度被视为“-”标志，后跟正字段宽度。在任何情况下都不存在不存在的
或者字段宽度太小导致字段被截断；如果转换结果比字段宽度宽，则字段
被扩展以包含转换结果。

精确
可选精度，采用句点 ('.') 后跟可选十进制数字字符串的形式。而不是一个决定
mal 数字字符串可以写“*”或“*m$”（对于某些十进​​制整数 m）来指定精度在
分别是下一个参数或第 m 个参数，其类型必须为 int。如果精度仅指定为“.”，
精度为零。负精度被视为如同省略精度一样。这给出了最小
d、i、o、u、x 和 X 转换中出现的imum位数，基数后出现的位数
a、A、e、E、f 和 F 转换的字符，g 和 G 转换的最大有效位数，或
用于 s 和 S 转换的字符串中要打印的最大字符数。

长度修饰符
这里，“整数转换”代表d、i、o、u、x或X转换。

hh 后面的整数转换对应于有符号 char 或无符号 char 参数，或者后面的 n 转换
sion 对应于指向有符号 char 参数的指针。

h 后面的整数转换对应于短或无符号短参数，或者后面的 n 转换
对应于指向短参数的指针。

l (ell) 后面的整数转换对应于 long 或 unsigned long 参数，或者后面的 n 转换
对应于指向 long 参数的指针，或者以下 c 转换对应于 wint_t 参数，或者
下面的 s 转换对应于指向 wchar_t 参数的指针。

ll（呃-呃）。下面的整数转换对应于一​​个 long long 或 unsigned long long 参数，或者一个下面的
lowing n 转换对应于指向 long long 参数的指针。

q ll 的同义词。这是一个非标准扩展，源自 BSD；避免在新代码中使用它。

a、A、e、E、f、F、g 或 G 转换后的 LA 对应于长双参数。（C99 允许 %LF，但是
SUSv2 没有。）

j 以下整数转换对应于 intmax_t 或 uintmax_t 参数，或以下 n 转换对应
响应指向 intmax_t 参数的指针。

z 以下整数转换对应于 size_t 或 ssize_t 参数，或以下 n 转换对应
响应指向 size_t 参数的指针。

Z 是 z 的非标准同义词，早于 z 的出现。不要在新代码中使用。

t 后面的整数转换对应于 ptrdiff_t 参数，或者后面的 n 转换对应于
指向 ptrdiff_t 参数的指针。

SUSv3 指定了上述所有内容，但明确指出为非标准扩展的那些修饰符除外。SUSv2
仅指定长度修饰符 h（在 hd、hi、ho、hx、hX、hn 中）和 l（在 ld、li、lo、lx、lX、ln、lc、ls 中）和 L（在
Le、LE、Lf、Lg、LG）。

作为一种非标准扩展，GNU 实现将 ll 和 L 视为同义词，因此可以编写 llg
（作为符合标准的 Lg 的同义词）和 Ld （作为符合标准的 lld 的同义词）。这种用法是非
便携的。

转换说明符
指定要应用的转换类型的字符。转换说明符及其含义是：

d, i int 参数转换为有符号十进制表示法。精度（如果有）给出了最小数量
必须出现的数字；如果转换后的值需要较少的数字，则在左侧用零填充。这
默认精度为 1。当使用显式精度 0 打印 0 时，输出为空。

o、u、x、X
unsigned int 参数转换为无符号八进制 (o)、无符号十进制 (u) 或无符号十六进制 (x
X) 符号。字母 abcdef 用于 x 转换；字母 ABCDEF 用于 X 转换。
精度（如果有）给出必须出现的最小位数；如果转换后的值需要更少
数字，它在左侧用零填充。默认精度为 1。当使用显式打印 0 时
精度为0，输出为空。

e, E 双参数按 [-]d.ddde±dd 格式四舍五入并转换，其中有一位数字（非零）
如果参数非零）小数点字符之前和之后的位数等于
精确; 如果精度缺失，则取6；如果精度为零，则没有小数点字符
出现。E 转换使用字母 E（而不是 e）来引入指数。指数总是与
至少包含两位数字；如果该值为零，则指数为 00。

f, F 双参数被四舍五入并转换为格式为 [-]ddd.ddd 的十进制表示法，其中
小数点字符后的数字等于精度规格。如果精度缺失，
取6；如果精度明确为零，则不会出现小数点字符。如果有小数点
出现时，其前面至少出现一位数字。

（SUSv2 不知道 F 并表示可以对无穷大和 NaN 进行字符串表示
可用的。SUSv3 增加了对 F 的规范。C99 标准指定“[-]inf”或“[-]infinity”表示无穷大，
在 f 转换的情况下，以“nan”开头的字符串表示 NaN，以及“[-]INF”或“[-]INFINITY”或“NAN”
F 转换的情况。）

g, G 双参数以 f 或 e 样式转换（或 G 转换为 F 或 E）。精度指定了数量
有效数字的 ber。如果精度缺失，则给出6位；如果精度为零，则为
视为 1。如果转换后的指数小于 -4 或大于或等于，则使用样式 e
精度。从结果的小数部分中删除尾随零；只出现小数点
如果后面至少有一位数字。

a, A（C99；不在 SUSv2 中，但在 SUSv3 中添加）对于转换，双精度参数将转换为十六进制符号
化（使用字母 abcdef），样式为 [-]0xh.hhhhp±d；对于 A 转换，前缀 0X、字母 ABCDEF、
并使用指数分隔符P。小数点前有一位十六进制数字，其个数
它后面的数字等于精度。默认精度足以精确表示
如果存在以 2 为基数的精确表示，则值足够大以区分
输入双倍。对于非标准化数字，小数点前的数字未指定，并且非零但其他 -
对于标准化数字来说，明智的未指定。指数始终至少包含一位数字；如果该值为零，
指数为0。

c 如果不存在 l 修饰符，则 int 参数将转换为 unsigned char，结果字符为
书面。如果存在 l 修饰符，wint_t（宽字符）参数将转换为多字节序列
通过调用 wcrtomb(3) 函数，转换状态从初始状态开始，以及结果
写入多字节字符串。

s 如果不存在 l 修饰符：const char * 参数应为指向字符类型数组的指针
（指向字符串的指针）。数组中的字符被写入（但不包括）终止空字节
('\0'); 如果指定了精度，则写入的数量不超过指定的数量。如果给出精度，则不
需要存在空字节；如果未指定精度，或者大于数组的大小，则数组
必须包含终止空字节。

如果存在 l 修饰符： const wchar_t * 参数预计是指向宽字符数组的指针
之三。数组中的宽字符转换为多字节字符（每个字符都通过调用 wcrtomb(3)
函数，转换状态从第一个宽字符之前的初始状态开始），直到
包括终止空宽字符。结果多字节字符被写入（但不包括
ing) 终止空字节。如果指定了精度，则写入的字节数不会多于指定的数量。
十个，但没有写入部分多字节字符。注意，精度决定了字节数
书面的，而不是宽字符的数量或屏幕位置。该数组必须包含终止 null 宽
字符，除非给出了精度并且它太小以至于写入的字节数超过了它之前的字节数
已到达数组末尾。

C（不在 C99 或 C11 中，但在 SUSv2、SUSv3 和 SUSv4 中。）lc 的同义词。不要使用。

S（不在 C99 或 C11 中，但在 SUSv2、SUSv3 和 SUSv4 中。）ls 的同义词。不要使用。

p void * 指针参数以十六进制打印（就像通过 %#x 或 %#lx 一样）。

n 到目前为止写入的字符数存储到相应参数指向的整数中。
该参数应为 int * 或其大小与（可选）提供的整数长度修饰符匹配的变体。
没有参数被转换。（仿生 C 库不支持此说明符。）行为未定义
如果转换规范包含任何标志、字段宽度或精度。

m（Glibc 扩展；受 uClibc 和 musl 支持。）打印 strerror(errno) 的输出。无需论证。

% 写入“%”。没有参数被转换。完整的转换规范是“%%”。

返回值
成功返回后，这些函数返回打印的字符数（不包括用于结束的空字节）
输出到字符串）。

函数 snprintf() 和 vsnprintf() 写入的内容不会超过 size 字节（包括终止空字节 ('\0')）。
如果输出由于此限制而被截断，则返回值是字符数（不包括术语）
如果有足够的可用空间，该字节将被写入最终字符串。因此，返回
size 或更大的值意味着输出被截断。（另请参阅下面的“注释”部分。）

如果遇到输出错误，则返回负值。

属性
有关本节中使用的术语的解释，请参阅 attribute(7)。

┌────────────────────────┬────────────────┬──────── ────────┐
│接口 │属性 │值 │
├────────────────────────┼────────────────┼──────── ────────┤
│printf(), fprintf(), │ 线程安全 │ MT 安全语言环境 │
│sprintf(), snprintf(), │ │ │
│vprintf(), vfprintf(), │ │ │
│vsprintf(), vsnprintf() │ │ │
└────────────────────────┴────────────────┴──────── ────────┘

符合
fprintf()、printf()、sprintf()、vprintf()、vfprintf()、vsprintf()：POSIX.1-2001、POSIX.1-2008、C89、C99。

snprintf()、vsnprintf()：POSIX.1-2001、POSIX.1-2008、C99。

dprintf() 和 vdprintf() 函数最初是 GNU 扩展，后来在 POSIX.1-2008 中标准化。

关于 snprintf() 的返回值，SUSv2 和 C99 相互矛盾：当以 size=0 调用 snprintf() 时
那么SUSv2规定一个小于1的未指定返回值，而C99在这种情况下允许str为NULL，并给出
返回值（一如既往）作为输出字符串已写入的字符数
足够大。POSIX.1-2001 及更高版本将其 snprintf() 规范与 C99 保持一致。

glibc 2.1 添加了长度修饰符 hh、j、t 和 z 以及转换字符 a 和 A。

glibc 2.2 添加了具有 C99 语义的转换字符 F 和标志字符 I。

笔记
有些程序不谨慎地依赖如下代码

sprintf(buf, "%s 一些进一步的文本", buf);

将文本附加到 buf。然而，标准明确指出，如果源和目标
调用 sprintf()、snprintf()、vsprintf() 和 vsnprintf() 时缓冲区重叠。取决于 gcc 的版本(1)
使用的，以及使用的编译器选项，诸如上述的调用将不会产生预期的结果。

函数 snprintf() 和 vsnprintf() 的 glibc 实现符合 C99 标准，即行为如下
如上所述，自 glibc 版本 2.1 起。在 glibc 2.0.6 之前，当输出被截断时，它们会返回 -1。

错误
因为 sprintf() 和 vsprintf() 假定一个任意长的字符串，所以调用者必须小心不要溢出实际的字符串。
空间; 这通常是无法保证的。请注意，生成的字符串的长度取决于语言环境并且存在差异。
邪教来预测。请改用 snprintf() 和 vsnprintf()（或 asprintf(3) 和 vasprintf(3)）。

代码如 printf(foo); 通常表示错误，因为 foo 可能包含 % 字符。如果 foo 来自不受信任的用户
输入，它可能包含 %n，导致 printf() 调用写入内存并创建安全漏洞。

例子
要将 Pi 打印到小数点后五位：

#include <数学.h>
#include <stdio.h>
fprintf(stdout, "pi = %.5f\n", 4 * atan(1.0));

要以“Sunday, July 3, 10:02”的形式打印日期和时间，其中工作日和月份是指向字符串的指针：

#include <stdio.h>
fprintf(stdout, "%s, %s %d, %.2d:%.2d\n",
工作日、月、日、小时、分钟）；

许多国家/地区使用日-月-年顺序。因此，国际化版本必须能够打印参数
由格式指定的订单：

#include <stdio.h>
fprintf（标准输出，格式，
工作日、月、日、小时、分钟）；

其中格式取决于语言环境，并且可能会排列参数。具有值：

“%1$s，%3$d。%2$s，%4$d：%5$.2d\n”

人们可能会得到“Sonntag，3. Juli，10:02”。

要分配足够大的字符串并打印到其中（对于 glibc 2.0 和 glibc 2.1 来说代码都是正确的）：

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

字符*
make_message(const char *fmt, ...)
{
整数 n = 0;
size_t 大小 = 0;
字符 *p = NULL;
va_list ap；

/* 确定所需大小 */

va_start(ap, fmt);
n = vsnprintf(p, 大小, fmt, ap);
va_end(ap);

如果（n<0）
返回空值；

/* '\0' 多一个字节 */

大小 = (size_t) n + 1;
p = malloc(大小);
如果（p==NULL）
返回空值；

va_start(ap, fmt);
n = vsnprintf(p, 大小, fmt, ap);
va_end(ap);

如果（n<0）{
免费（p）；
返回空值；
}

返回p；
}

如果在 2.0.6 之前的 glibc 版本中发生截断，则会将其视为错误，而不是妥善处理。

也可以看看
printf(1)、asprintf(3)、puts(3)、scanf(3)、setlocale(3)、strfromd(3)、wcrtomb(3)、wprintf(3)、区域设置(5)

版画
本页是 Linux 手册页项目 5.10 版的一部分。项目描述、有关重新设计的信息
移植错误以及本页面的最新版本可以在 https://www.kernel.org/doc/man-pages/ 找到。

GNU 2020-11-01 PRINTF(3)
