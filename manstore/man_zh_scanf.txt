SCANF(3) Linux 程序员手册 SCANF(3)

姓名
scanf、fscanf、sscanf、vscanf、vsscanf、vfscanf - 输入格式转换

概要
#include <stdio.h>

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);

#include <stdarg.h>

int vscanf(const char *format, va_​​list ap);
int vsscanf(const char *str, const char *format, va_​​list ap);
int vfscanf(FILE *stream, const char *format, va_​​list ap);

glibc 的功能测试宏要求（请参阅 feature_test_macros(7)）：

vsscanf()、vscanf()、vfscanf()：
_ISOC99_源|| _POSIX_C_SOURCE >= 200112L

描述
scanf() 函数系列根据如下所述的格式扫描输入。此格式可能包含转换
规格; 此类转换的结果（如果有）存储在指针参数指向的位置中
遵循格式的评论。每个指针参数的类型必须适合于返回值
相应的转换规范。

如果格式中转换规范的数量超过指针参数的数量，则结果未定义。
如果指针参数的数量超过转换规范的数量，则超出的指针参数
会被评估，但会被忽略。

scanf()函数从标准输入流stdin读取输入，fscanf()从流指针读取输入
Stream，sscanf() 从 str 指向的字符串中读取其输入。

vfscanf() 函数类似于 vfprintf(3)，并使用变量参数从流指针流读取输入
指针列表（参见 stdarg(3)）。vscanf() 函数从标准输入扫描变量参数列表，并
vsscanf() 函数从字符串中扫描它；这些类似于 vprintf(3) 和 vsprintf(3) 函数
积极地。

格式字符串由一系列指令组成，这些指令描述如何处理输入字符序列。
如果指令处理失败，则不会读取进一步的输入，并且 scanf() 返回。“失败”可以是以下任一情况
以下：输入失败，表示输入字符不可用，或匹配失败，表示输入
不合适（见下文）。

指令是以下之一：

• 一系列空白字符（空格、制表符、换行符等；请参阅isspace(3)）。该指令匹配任何
输入中的空白量，包括无空白。

• 普通字符（即除空格或“%”之外的字符）。该字符必须与下一个字符完全匹配
输入的字符。

• 转换规范，以“%”（百分比）字符开头。来自的字符序列
输入按照此规范进行转换，结果放入相应的指针参数中
ment。如果下一项输入与转换规范不匹配，则转换失败——这是一个
匹配失败。

format 中的每个转换规范以字符“%”或字符序列“%n$”开头（见下文）
为了区分），然后是：

• 可选的“*”赋值抑制字符：scanf() 按照转换规范的指示读取输入。
化，但丢弃输入。不需要相应的指针参数，并且该规范不包含在-
包含在 scanf() 返回的成功分配的计数中。

• 对于十进制转换，可选引号字符(')。这指定输入数字可能包括thou-
由当前语言环境的 LC_NUMERIC 类别定义的 sands 分隔符。（请参阅 setlocale(3)。） 引用
字符可以在“*”赋值抑制字符之前或之后。

• 可选的“m”字符。这与字符串转换（%s、%c、%[）一起使用，并减轻了调用者的负担
需要分配一个相应的缓冲区来保存输入：相反，scanf()分配一个足够的缓冲区
size，并将该缓冲区的地址分配给相应的指针参数，该参数应该是指向
一个 char * 变量（该变量不需要在调用前初始化）。调用者应该继续
当不再需要该缓冲区时，立即释放(3)该缓冲区。

• 指定最大字段宽度的可选十进制整数。字符读取停止时
达到此最大值或找到不匹配的字符时，以先发生者为准。大多数转换都
卡初始空白字符（例外情况如下所述），这些被丢弃的字符不计算在内
朝向最大字段宽度。字符串输入转换存储终止空字节（'\0'）来标记字符串的结束
输入；最大字段宽度不包括该终止符。

• 可选的类型修饰符。例如，l 类型修饰符与整数转换一起使用，例如
%d 指定相应的指针参数引用 long 而不是指向 int 的指针。

• 转换说明符，指定要执行的输入转换的类型。

format中的转换规范有两种形式，要么以'%'开头，要么以“%n$”开头。他们俩
表单不应混合在同一格式字符串中，但包含“%n$”规范的字符串可以包含%%
和 ％*。如果 format 包含 '%' 规范，则它们按顺序与连续的指针参数相对应。在
“%n$”形式（在 POSIX.1-2001 中指定，但在 C99 中没有指定），n 是一个十进制整数，指定 con-
verted 输入应放置在遵循格式的第 n 个指针参数引用的位置。

转换
以下类型修饰符字符可以出现在转换规范中：

h 指示转换将是 d、i、o、u、x、X 或 n 之一，并且下一个指针是指向短整型的指针
或无符号短整型（而不是 int）。

hh 与h 相同，但next 指针是指向signed char 或unsigned char 的指针。

j 与 h 相同，但下一个指针是指向 intmax_t 或 uintmax_t 的指针。该修饰符是在 C99 中引入的。

l 指示转换将是 d、i、o、u、x、X 或 n 之一，并且下一个指针是指向 a 的指针
long 或 unsigned long（而不是 int），或者转换将是 e、f 或 g 之一，并且下一个指针是
指向 double（而不是 float）的指针。指定两个 l 字符相当于 L。如果与 %c 或 %s 一起使用，
相应的参数分别被视为指向宽字符或宽字符字符串的指针。

L 表示转换为 e、f 或 g，并且下一个指针是指向 long double 或
转换将为 d、i、o、u 或 x，下一个指针是指向 long long 的指针。

q 相当于 L。该说明符在 ANSI C 中不存在。

t 与 h 相同，但下一个指针是指向 ptrdiff_t 的指针。该修饰符是在 C99 中引入的。

z 与h一样，但next指针是指向size_t的指针。该修饰符是在 C99 中引入的。

可以使用以下转换说明符：

% 匹配文字“%”。也就是说，格式字符串中的 %% 与单个输入“%”字符匹配。没有转换是
完成（但初始空白字符被丢弃），并且不会发生赋值。

d 匹配一个可选的有符号十进制整数；next 指针必须是指向 int 的指针。

i 匹配一个可选的有符号整数；next 指针必须是指向 int 的指针。整数以 16 为基数读取
如果以 0x 或 0X 开头，则以 0 开头则以 8 为基数，否则以 10 为基数。仅对应的字符
响应基地被使用。

o 匹配无符号八进制整数；next 指针必须是指向 unsigned int 的指针。

u 匹配无符号十进制整数；next 指针必须是指向 unsigned int 的指针。

x 匹配一个无符号的十六进制整数（可以选择以 0x 或 0X 前缀开头，这是
梳理）；next 指针必须是指向 unsigned int 的指针。

X 等于 x。

f 匹配一个可选的有符号浮点数；下一个指针必须是浮点指针。

e 相当于 f。

g 相当于 f。

E 相当于 f。

a (C99) 相当于 f。

s 匹配非空白字符序列；next 指针必须是指向 a 的初始元素的指针
足够长以容纳输入序列和终止空字节（'\0'）的字符数组，即
自动添加。输入字符串在空白处或最大字段宽度处停止，以发生的情况为准
第一的。

c 匹配字符序列，其长度由最大字段宽度指定（默认1）；下一个
指针必须是指向 char 的指针，并且必须有足够的空间容纳所有字符（没有终止空字节
被添加）。通常跳过前导空白的现象被抑制。要首先跳过空格，请使用显式
格式中的空格。

[ 匹配指定的接受字符集中的非空字符序列；下一个指针必须是
指向 char 的指针，并且必须有足够的空间容纳字符串中的所有字符，加上终止 null
字节。通常跳过前导空白的现象被抑制。该字符串由（或不是）中的字符组成
in）特定的集合；该集合由开括号 [ 字符和闭括号之间的字符定义
括号] 字符。如果开括号后的第一个字符是循环字符，则该集合会排除这些字符。
累积弹性 (^)。要在集合中包含右括号，请将其作为左括号或
抑扬音；任何其他位置都将结束该组。连字符 - 也很特殊；当放置在两个之间时
其他字符，它将所有中间字符添加到集合中。要包含连字符，请将其作为最后一个字符
在最后一个右括号之前。例如，[^]0-9-] 表示集合“除了右括号之外的所有内容，零
到九和连字符”。字符串以不在 ( 或带有扬抑符，
in) 设置或当字段宽度用完时。

p 匹配指针值（如 printf(3) 中 %p 打印的那样）；next 指针必须是指向 void 的指针。

n 没有什么可期待的；相反，到目前为止从输入消耗的字符数通过
next 指针，必须是指向 int 的指针。这不是转化，不会增加返回的计数
通过函数。可以使用 * 赋值抑制字符来抑制赋值，但效果
返回值未定义。因此不应使用 %*n 转换。

返回值
成功时，这些函数返回成功匹配和分配的输入项的数量；这可以少于
如果早期匹配失败，则提供，甚至为零。

如果在第一次成功转换或匹配之前到达输入末尾，则返回值 EOF
发生故障。如果发生读取错误，也会返回 EOF，在这种情况下，流的错误指示符（请参阅 fer-
ror(3)) 已设置，并且 errno 已设置以指示错误。

错误
EAGAIN 流底层的文件描述符被标记为非阻塞，读操作会阻塞。

EBADF 底层流的文件描述符无效，或者未打开以供读取。

EILSEQ 输入字节序列未形成有效字符。

EINTR 读操作被信号中断；参见信号(7)。

EINVAL 参数不足；或格式为 NULL。

ENOMEM 内存不足。

ERANGE 整数转换的结果将超出相应整数类型可以存储的大小。

属性
有关本节中使用的术语的解释，请参阅 attribute(7)。

┌──────────────────────┬────────────────┬──────────── ──────┐
│接口 │属性 │值 │
├──────────────────────┼────────────────┼──────────── ──────┤
│scanf(), fscanf(), │ 线程安全 │ MT 安全语言环境 │
│sscanf(), vscanf(), │ │ │
│vsscanf(), vfscanf() │ │ │
└──────────────────────┴────────────────┴──────────── ──────┘

符合
函数 fscanf()、scanf() 和 sscanf() 符合 C89 和 C99 以及 POSIX.1-2001。这些标准没有具体规定
错误。

q 说明符是 4.4BSD 中 long long 的表示法，而 ll 或在整数转换中使用 L 是 GNU 表示法。
。

这些函数的 Linux 版本基于 GNU libio 库。看看GNU的信息文档
libc (glibc-1.08) 以获得更简洁的描述。

笔记
'a' 赋值分配修饰符
最初，GNU C 库支持通过 a 动态分配字符串输入（作为非标准扩展）
特点。（此功能至少早在 glibc 2.0 就已存在。）因此，可以编写以下内容来获得
scanf() 为输入字符串分配一个缓冲区，并在 *buf 中返回指向该缓冲区的指针：

字符*缓冲区；
scanf("%as", &buf);

为此目的使用字母 a 是有问题的，因为 ISO C 标准也将 a 指定为同义词
对于 f（浮点输入）。POSIX.1-2008 相反指定了用于分配分配的 m 修饰符（如记录在
描述，见上文）。

请注意，如果程序是使用 gcc -std=c99 或 gcc -D_ISOC99_SOURCE 编译的，则 a 修饰符不可用（除非
_GNU_SOURCE 也被指定），在这种情况下 a 被解释为浮点数的说明符（参见
多于）。

从版本 2.7 开始，glibc 添加了对 m 修饰符的支持，新程序应该在以下位置使用该修饰符：
而不是 a.

除了被 POSIX 标准化之外，m 修饰符比使用 a 还具有以下优点：

* 它也可以应用于%c 转换说明符（例如%3mc）。

* 它避免了 %a 浮点转换说明符的歧义（并且不受 gcc -std=c99 的影响
ETC。）。

错误
所有函数完全符合 C89，但提供附加说明符 q 和 a 以及附加行为
L 和 l 说明符。后者可能被认为是一个错误，因为它改变了定义的说明符的行为
在C89中。

ANSI C 定义的类型修饰符和转换说明符的某些组合没有意义（例如，%Ld）。
虽然它们在 Linux 上可能具有明确定义的行为，但在其他体系结构上则不必如此。因此它通常
ally 最好使用根本不是 ANSI C 定义的修饰符，即使用 q 而不是 L 与
d、i、o、u、x 和 X 转换或 ll。

q 的用法与 4.4BSD 上不同，因为它可以与 L 等效地用于浮点转换。

例子
要使用动态分配转换说明符，请将 m 指定为长度修饰符（即 %ms 或 %m[range]）。呼叫者，召集者
必须 free(3) 返回的字符串，如下例所示：

字符*p；
整数 n;

错误号=0；
n = scanf("%m[az]", &p);
如果（n==1）{
printf("读取：%s\n", p);
免费（p）；
} 否则 if (errno != 0) {
错误（“scanf”）；
} 别的 {
fprintf(stderr, "没有匹配的字符\n");
}

如上例所示，只有当 scanf() 调用成功读取字符串时，才需要调用 free(3)。

也可以看看
getc(3)、printf(3)、setlocale(3)、strtod(3)、strtol(3)、strtoul(3)

版画
本页是 Linux 手册页项目 5.10 版的一部分。项目描述、有关重新设计的信息
移植错误以及本页面的最新版本可以在 https://www.kernel.org/doc/man-pages/ 找到。

GNU 2020-08-13 扫描(3)
